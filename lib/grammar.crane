%left \compare
%left \logical
%left \linear
%left \scalar
%right \pow
%none '{' '(' '[' ']' ')' '}' '.'

module
    > @multiple(statement, sep)    =>
        new @node.Program do
            sourceType: 'module'
            body: $[0]

identifier
    > \id   => new @node.Identifier(name: $[0])

literal
    > \null         => @literal null
    > \undefined    => @literal undefined
    > \true         => @literal true
    > \false        => @literal false
    > \number       => @literal parseFloat $[0]
    > \string       => @literal $[0].slice 1, -1

sep
    > ','
    > \nl

member-access
    # member expressions
    > e \. identifier   =>
        new @node.MemberExpression do
            object: $[0]
            property: $[2]
            computed: false

    > \this identifier  =>
        new @node.MemberExpression do
            object: new @node.ThisExpression({loc: null})
            property: $[1]
            computed: false

    > e '[' e ']'  =>
        new @node.MemberExpression do
            object: $[0]
            property: $[2]
            computed: true

e
    splat
        > \... e
        
    array
        component
            > e
        
        > '[' @multiple(component, sep) ']'     => new @node.ArrayExpression elements: $[1]
    
    object
        property
            > identifier  =>
                new @node.Property do
                    key: $[0]
                    value: $[0]
                    method: false
                    shorthand: true
                    computed: false
                    kind: 'init'
                
            > identifier ':' e  =>
                new @node.Property do
                    key: $[0]
                    value: $[2]
                    method: false
                    shorthand: false
                    computed: false
                    kind: 'init'

            > identifier function  =>
                new @node.Method do
                    id: $[0]
                    definition: $[1]
                    kind: null
                    
            > \get identifier function =>
                new @node.Method do
                    id: $[1]
                    definition: $[2]
                    kind: 'get'
            
            > \set identifier function =>
                new @node.Method do
                    id: $[1]
                    definition: $[2]
                    kind: 'set'
            
        > '{' @multiple(property, sep) '}'      => new @node.ObjectExpression properties: $[1]
    
    compare-chain
        > e \compare e =>
            new @node.CompareChainExpression do
                operators: [$[1]]
                expressions: [$[0], $[2]]

        > compare-chain \compare e =>
            new @node.CompareChainExpression do
                operators: [...$[0].operators, $[1]]
                expressions: [...$[0].expressions, $[2]]


    > e \scalar e       => @binaryExpression($)
    > e \linear e       => @binaryExpression($)
    > e \pow e          => @binaryExpression($)
    > e \logical e      => @binaryExpression($)
    > \linear e         => @unaryExpression($)
    > \! e              => @unaryExpression($)
    > \not e            => @unaryExpression($)
    > '(' e ')'         => $[1]
    > function          => new @node.FunctionExpression($[0])
    > array
    > object
    > literal
    > identifier
    > member-access
    > compare-chain

    > \await e =>
        new @node.AwaitExpression do
            argument: $[1]

    # call expression
    > e '(' @multiple(e, ',') ')'    =>
        new @node.CallExpression do
            callee: $[0]
            arguments: $[2]
    
    > \this => new @node.ThisExpression({})
    
block
    > '{' @multiple(statement, \nl) '}'            => $[1]
    > \indent @multiple(statement, \nl) \dedent    => $[1]

function
    parameter
        > identifier
        > identifier \= e

    bound
        > \->
        > \=>
    
    type
        > \*
        > \~
        > \~*

    params
        > @multiple(parameter, ',')
        
    body
        > block => new @node.BlockStatement(body: $[0])
        
    > \fn '(' params ')' body  =>
        new @node.Function do
            params: $[2]
            body: $[4]
            async: false
            generator: false
            bound: null

    > \fn '(' params ')' bound body  =>
        new @node.Function do
            params: $[2]
            body: $[5]
            async: false
            generator: false
            bound: $[4] == "=>"

    > \fn '(' params ')' type body  =>
        new @node.Function do
            params: $[2]
            body: $[5]
            async: $[4].includes '~'
            generator: $[4].includes '*'
            bound: null

    > \fn '(' params ')' bound type body  =>
        new @node.Function do
            params: $[2]
            body: $[6]
            async: $[5].includes '~'
            generator: $[5].includes '*'
            bound: $[4] == '=>'        

assignment-pattern
    object-pattern
        property
            > identifier ':' assignment-pattern =>
                new @node.AssignmentProperty do
                    key: $[0]
                    value: $[2]
                    kind: 'init'
                    method: false
                    shorthand: false
                    computed: false

            > identifier =>
                new @node.AssignmentProperty do
                    key: $[0]
                    value: $[0]
                    kind: 'init'
                    method: false
                    shorthand: false
                    computed: false

        > '{' @multiple(property, ',') '}' =>
            new @node.ObjectPattern(properties: $[1])

    array-pattern
        component
            > identifier
            > assignment-pattern

        > '[' @multiple(component, ',') ']' =>
            new @node.ArrayPattern(elements: $[1])

    > object-pattern
    > array-pattern


statement
    blockable-statement

        blocky
            > blockable-statement
            > block                 => new @node.BlockStatement(body: $[0])

        while-statement
            > \while e blocky =>
                new @node.WhileStatement do
                    test: $[1]
                    body: $[2]

        for-statement
            > \for identifier \in e blocky =>
                new @node.ForInStatement do
                    left: $[1]
                    right: $[3]
                    block: $[4]


        do-statement
            > \do block     => new @node.BlockStatement(body: $[1])


        if-statement
            > \if e blocky =>
                new @node.IfStatement do
                    test: $[1]
                    consequent: $[2]
                    alternate: null

            > \if e blocky \else blocky =>
                new @node.IfStatement do
                    test: $[1]
                    consequent: $[2]
                    alternate: $[4]

        try-statement
            catch-clause
                > \catch identifier blocky =>
                    new @node.CatchClause do
                        param: $[1]
                        body: $[2]

            > \try blocky catch-clause =>
                new @node.TryStatement do
                    block: $[1]
                    handler: $[2]
                    finalizer: null

            > \try blocky catch-clause \finally blocky =>
                new @node.TryStatement do
                    block: $[1]
                    handler: $[2]
                    finalizer: $[4]

            > \try blocky \finally blocky =>
                new @node.TryStatement do
                    block: $[1]
                    handler: null
                    finalizer: $[3]

        > while-statement
        > for-statement
        > if-statement
        > try-statement
        > do-statement

    declaration
        assignee
            > identifier
            > \assign assignment-pattern => $[1]

        declarator
            > assignee  =>
                new @node.VariableDeclarator do
                    constant: false
                    id: $[0]
                    init: null
                    
            > assignee \= e  =>
                new @node.VariableDeclarator do
                    constant: true
                    id: $[0]
                    init: $[2]
                    
            > assignee \:= e  =>
                new @node.VariableDeclarator do
                    constant: false
                    id: $[0]
                    init: $[2]
        
        declarators
            > declarator                    => [$[0]]
            > declarators ',' declarator    => [...$[0], $[2]]
        
        > \def declarators  =>
            new @node.VariableDeclaration do
                declarations: $[1]
        
        > \def identifier function    =>
            new @node.FunctionDeclaration do
                id: $[1]
                value: $[2]

    assignment-statement
        assignee
            > identifier
            > member-access

        > assignee '=' e  =>
            new @node.AssignmentStatement do
                left: $[0]
                right: $[2]
                operator: '='

        > assignee \reassign e =>
            new @node.AssignmentStatement do
                left: $[0]
                right: $[2]
                operator: $[1]

        > \assign assignment-pattern '=' e =>
            new @node.AssignmentStatement do
                left: $[1]
                right: $[3]
                operator: '='

    control-flow-statement
        return-statement
            > \return       => new @node.ReturnStatement argument: null
            > \return e     => new @node.ReturnStatement argument: $[1]

        yield-statement
            > \yield =>
                new @node.YieldStatement do
                    argument: null

            > \yield e =>
                new @node.YieldStatement do
                    argument: $[1]

        > return-statement
        > yield-statement

        > \break =>
            new @node.BreakStatement do
                label: null

        > \continue =>
            new @node.ContinueStatement do
                label: null

    > blockable-statement
    > declaration
    > assignment-statement
    > control-flow-statement
    > e =>
        new @node.ExpressionStatement do
            expression: $[0]
